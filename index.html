<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510; /* æ·±å¤œè“èƒŒæ™¯ */
            font-family: 'Arial', sans-serif;
            user-select: none;
            cursor: pointer; /* é¼ æ ‡å˜ä¸ºæ‰‹å‹ï¼Œæç¤ºå¯ç‚¹å‡» */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* æ ‡é¢˜æ ·å¼ - æ‚¨å¯ä»¥åœ¨è¿™é‡Œä¿®æ”¹å­—ä½“æˆ–é¢œè‰² */
        #title-overlay {
            position: absolute;
            top: 15%; /* ä½ç½®åœ¨ä¸­åä¸Š */
            left: 0;
            width: 100%;
            text-align: center;
            color: #ffffff;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€æ–‡å­—ï¼Œä¸å½±å“3Dæ“ä½œ */
            z-index: 10;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 0, 0, 0.5);
            animation: floatText 3s ease-in-out infinite;
        }

        #main-title {
            font-size: 4rem;
            font-weight: bold;
            margin: 0;
            letter-spacing: 5px;
            font-family: 'Georgia', serif; /* ä½¿ç”¨è¡¬çº¿å­—ä½“æ›´æœ‰èŠ‚æ—¥æ„Ÿ */
        }

        #sub-title {
            font-size: 1.5rem;
            margin-top: 10px;
            color: #e0e0e0;
        }

        /* éŸ³ä¹æ’­æ”¾æŒ‰é’®/æç¤º */
        #music-control {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            font-size: 14px;
        }

        #music-control:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%) scale(1.05);
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            #main-title { font-size: 2.5rem; }
            #sub-title { font-size: 1rem; }
            #title-overlay { top: 10%; }
        }
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- æ ‡é¢˜åŒºåŸŸ -->
    <div id="title-overlay">
        <!-- 
            ========================================
            åœ¨æ­¤å¤„ä¿®æ”¹æ ‡é¢˜æ–‡å­—
            ========================================
        -->
        <h1 id="main-title">MERRY CHRISTMAS</h1>
        <div id="sub-title">ç‹è²</div>
    </div>

    <!-- éŸ³ä¹æ§åˆ¶æŒ‰é’® -->
    <div id="music-control">âœ¨ æ’­æ”¾éŸ³ä¹ âœ¨</div>
    
    <!-- 3D å®¹å™¨ -->
    <div id="canvas-container"></div>

    <audio id="bgm" loop>
        <source src="./We%20wish%20you%20a%20merry%20chrismas.mp3" type="audio/mp3">
    </audio>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- é…ç½®åŒºåŸŸ ---
        const CONFIG = {
            treeHeight: 30,
            treeRadius: 10,
            particleCount: 5000,
            snowCount: 800,
            colorLeaf: 0x0f9b0f,
            colorStar: 0xffd700,
        };

        // --- åˆå§‹åŒ–åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;

        // --- è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆåœ†å½¢å‘å…‰çº¹ç† (ç”¨äºæ ‘å’ŒèƒŒæ™¯é›ª) ---
        function createTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createTexture();

        // --- è¾…åŠ©å‡½æ•°ï¼šç”ŸæˆçœŸæ­£çš„å…­è§’é›ªèŠ±çº¹ç† (ç”¨äºé¼ æ ‡äº¤äº’ç‰¹æ•ˆ) ---
        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.translate(32, 32);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#ffffff';

            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, 25);
                ctx.stroke();
                // åˆ†æ”¯
                ctx.beginPath();
                ctx.moveTo(0, 15);
                ctx.lineTo(8, 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, 15);
                ctx.lineTo(-8, 20);
                ctx.stroke();
                
                ctx.rotate(Math.PI / 3);
            }
            return new THREE.CanvasTexture(canvas);
        }
        const snowflakeTexture = createSnowflakeTexture();


        // --- åˆ›å»ºåœ£è¯æ ‘ (èºæ—‹ç²’å­ç³»ç»Ÿ) ---
        const treeGeometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const phases = [];

        const colorGreen = new THREE.Color(CONFIG.colorLeaf);
        const colorRed = new THREE.Color(0xff0000);
        const colorGold = new THREE.Color(0xffd700);
        const colorBlue = new THREE.Color(0x00ccff);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const angle = (i / CONFIG.particleCount) * Math.PI * 40;
            const y = (i / CONFIG.particleCount) * CONFIG.treeHeight;
            const radius = (1 - i / CONFIG.particleCount) * CONFIG.treeRadius;
            
            const randomX = (Math.random() - 0.5) * 0.5;
            const randomZ = (Math.random() - 0.5) * 0.5;
            const randomY = (Math.random() - 0.5) * 0.5;

            const x = Math.cos(angle) * radius + randomX;
            const z = Math.sin(angle) * radius + randomZ;

            positions.push(x, y + randomY, z);

            const rand = Math.random();
            let particleColor = colorGreen;
            let size = 0.4;

            if (rand > 0.9) { particleColor = colorRed; size = 2.5; }
            else if (rand > 0.8) { particleColor = colorGold; size = 2.5; }
            else if (rand > 0.7) { particleColor = colorBlue; size = 2.5; }

            colors.push(particleColor.r, particleColor.g, particleColor.b);
            sizes.push(size);
            phases.push(Math.random() * Math.PI * 2);
        }

        treeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        treeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        treeGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        treeGeometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));

        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pointTexture: { value: particleTexture }
            },
            vertexShader: `
                attribute float size;
                attribute float phase;
                varying vec3 vColor;
                uniform float time;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    float blink = 0.8 + 0.5 * sin(time * 2.0 + phase);
                    gl_PointSize = size * (300.0 / -mvPosition.z) * blink;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                    gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                    if (gl_FragColor.a < 0.1) discard;
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            vertexColors: true
        });

        const treeSystem = new THREE.Points(treeGeometry, shaderMaterial);
        treeSystem.position.y = -10;
        scene.add(treeSystem);

        // --- æ ‘é¡¶æ˜Ÿæ˜Ÿ ---
        const starGeo = new THREE.OctahedronGeometry(1.5, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.y = CONFIG.treeHeight - 10;
        
        const glowGeo = new THREE.PlaneGeometry(8, 8);
        const glowMat = new THREE.MeshBasicMaterial({
            map: particleTexture,
            color: 0xffd700,
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const starGlow = new THREE.Mesh(glowGeo, glowMat);
        starMesh.add(starGlow);
        scene.add(starMesh);

        // --- åœ°é¢åå°„ ---
        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const planeMat = new THREE.MeshBasicMaterial({
            color: 0x001133,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -10;
        scene.add(ground);
        
        const gridHelper = new THREE.GridHelper(100, 50, 0x112244, 0x000510);
        gridHelper.position.y = -10.1;
        scene.add(gridHelper);

        // --- èƒŒæ™¯é›ªèŠ±ç³»ç»Ÿ ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPositions = [];
        const snowVelocities = [];

        for(let i = 0; i < CONFIG.snowCount; i++) {
            snowPositions.push(
                (Math.random() - 0.5) * 100,
                (Math.random()) * 60 - 10,
                (Math.random() - 0.5) * 100
            );
            snowVelocities.push(0.02 + Math.random() * 0.05);
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
        const snowMat = new THREE.PointsMaterial({
            size: 0.6,
            map: particleTexture,
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            color: 0xffffff
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);


        // --- ç‚¹å‡»äº¤äº’å¤§é›ªèŠ±ç³»ç»Ÿ (Click Snow) ---
        const MAX_MOUSE_SNOW = 100;
        const mouseSnowGroup = new THREE.Group();
        scene.add(mouseSnowGroup);

        class MouseSnowflake {
            constructor() {
                const geo = new THREE.PlaneGeometry(2, 2);
                const mat = new THREE.MeshBasicMaterial({
                    map: snowflakeTexture,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.visible = false;
                this.active = false;
                this.life = 0;
                this.velocity = new THREE.Vector3();
                mouseSnowGroup.add(this.mesh);
            }

            spawn(position, scale = 1, offset = {x:0, y:0, z:0}) {
                this.mesh.position.set(
                    position.x + offset.x,
                    position.y + offset.y,
                    position.z + offset.z
                );
                this.mesh.rotation.z = Math.random() * Math.PI;
                this.mesh.visible = true;
                this.active = true;
                this.life = 1.0; 
                this.mesh.material.opacity = 1.0;
                this.mesh.scale.set(scale, scale, scale);
                // ç»™ä¸€ä¸ªè½»å¾®çš„éšæœºæ¨ªå‘é£˜åŠ¨é€Ÿåº¦
                this.velocity.set(
                    (Math.random() - 0.5) * 0.1,
                    -0.1 - Math.random() * 0.1, // ä¸‹è½é€Ÿåº¦
                    (Math.random() - 0.5) * 0.1
                );
            }

            update(delta) {
                if (!this.active) return;

                this.life -= delta * 0.4; // æ¶ˆå¤±é€Ÿåº¦
                
                // åº”ç”¨ä½ç½®æ›´æ–°
                this.mesh.position.add(this.velocity);
                // å¢åŠ æ—‹è½¬
                this.mesh.rotation.z += delta * 2;
                // ç¨å¾®å˜å°
                this.mesh.scale.multiplyScalar(0.99);

                this.mesh.material.opacity = this.life;

                if (this.life <= 0) {
                    this.active = false;
                    this.mesh.visible = false;
                }
            }
        }

        const mouseSnowflakes = [];
        for(let i=0; i<MAX_MOUSE_SNOW; i++) {
            mouseSnowflakes.push(new MouseSnowflake());
        }
        let mouseSnowIndex = 0;

        // é¼ æ ‡/ç‚¹å‡»äº‹ä»¶
        const mouse = new THREE.Vector2();

        // è¾…åŠ©å‡½æ•°ï¼šè§¦å‘é›ªèŠ±
        function triggerSnow(clientX, clientY) {
            // è®¡ç®—é¼ æ ‡çš„æ ‡å‡†åŒ–è®¾å¤‡åæ ‡
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            // æŠ•å½±åˆ°3Dç©ºé—´
            const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = 25; // åœ¨ç›¸æœºå‰æ–¹ 25 å¤„
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            // ä¸€æ¬¡ç”Ÿæˆ 3 ç‰‡ä¸åŒå¤§å°å’Œä½ç½®çš„é›ªèŠ±ï¼Œå½¢æˆç‚¹å‡»ç‰¹æ•ˆ
            for(let i=0; i<3; i++) {
                const snowflake = mouseSnowflakes[mouseSnowIndex];
                const scale = 0.8 + Math.random() * 0.8; // å¤§å°éšæœº
                const offset = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 1
                };
                snowflake.spawn(pos, scale, offset);
                mouseSnowIndex = (mouseSnowIndex + 1) % MAX_MOUSE_SNOW;
            }
        }

        // ç›‘å¬ç‚¹å‡»äº‹ä»¶ (pointerdown å…¼å®¹é¼ æ ‡å’Œè§¦æ‘¸)
        window.addEventListener('pointerdown', (event) => {
            // å¿½ç•¥éŸ³ä¹æŒ‰é’®çš„ç‚¹å‡»
            if(event.target.id === 'music-control') return;
            triggerSnow(event.clientX, event.clientY);
        });


        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            controls.update();

            // 1. æ ‘
            shaderMaterial.uniforms.time.value = time;

            // 2. æ˜Ÿæ˜Ÿ
            starMesh.rotation.y = time;
            starMesh.rotation.z = Math.sin(time) * 0.2;
            starGlow.lookAt(camera.position);

            // 3. èƒŒæ™¯é›ªèŠ±
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i = 0; i < CONFIG.snowCount; i++) {
                positions[i * 3 + 1] -= snowVelocities[i];
                if(positions[i * 3 + 1] < -10) {
                    positions[i * 3 + 1] = 50;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y = time * 0.05;

            // 4. ç‚¹å‡»å¤§é›ªèŠ±æ›´æ–°
            mouseSnowflakes.forEach(sf => sf.update(delta));

            // 5. è®©é¼ æ ‡é›ªèŠ±å§‹ç»ˆé¢å‘ç›¸æœº (Billboard)
            mouseSnowGroup.children.forEach(mesh => {
                if(mesh.visible) {
                    mesh.lookAt(camera.position);
                }
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- éŸ³ä¹æ§åˆ¶ ---
        const musicBtn = document.getElementById('music-control');
        const bgm = document.getElementById('bgm');
        let isPlaying = false;
        bgm.volume = 0.6;

        musicBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // é˜²æ­¢è§¦å‘é›ªèŠ±
            if (!isPlaying) {
                bgm.play().then(() => {
                    isPlaying = true;
                    musicBtn.textContent = "ğŸµ æ­£åœ¨æ’­æ”¾";
                    musicBtn.style.opacity = 0.5;
                }).catch(e => console.log(e));
            } else {
                bgm.pause();
                isPlaying = false;
                musicBtn.textContent = "ğŸ”‡ å·²æš‚åœ";
                musicBtn.style.opacity = 1;
            }
        });

        animate();

    </script>
</body>
</html>